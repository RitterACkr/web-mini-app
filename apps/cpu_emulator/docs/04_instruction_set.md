# Instruction Set (命令セット)

CPUは `命令` を順番に実行してプログラムを動かす

このプロジェクトでは命令を 1バイト (0..255) の数値で表す
```
0x01 = LDA_IMM
0x02 = LDB_IMM
0x03 = ADD
0x04 = PRINTA
0xFF = HALT
```

## opcode と operand
多くの命令は
- opcode : 命令本体 「何をするか」
- operand : 引数 「opcodeに対してどの値で行うか」
の2つから成る

```
例えば
LDA_IMM 5
はメモリ上では以下のように表される
0x00: 0x01 <- opcode
0x01: 0x05 <- operand

(PC=0では opcode=LDA_IMM を読む -> PC=1に移動)
(PC=1では immediate=5 を読む -> PC=2に移動)
```

### 命令ごとのバイト長
命令によっては operand の有無が異なるため,1命令が占めるバイト数は一定でない
```
ADD は読まれた時点でA += Bが行われるため, operand が必要ない
-> (1バイト命令)

LDA_IMM は引数 imm8 を持ち, operand を用いて指定する必要がある
-> (2バイト命令)
```

---

## このプロジェクトの命令セット

### LDA_IMM (0x01)

Aレジスタに即値 (imm8) をロードする
```
A = imm8
Z = (A == 0)

メモリ形式: [0x01][imm8]
```

### LDB_IMM (0x02)

Bレジスタに即値 (imm8) をロードする
```
B = imm8
Z = (B == 0)

メモリ形式: [0x02][imm8]
```

### ADD (0x03)

A と B を加算し, 結果を A に入れる
```
A = (A + B) & 0xFF
Z = (A == 0)

メモリ形式: [0x03]
```

### PRINTA (0x04)

Aレジスタの値を出力する (表示/ログに追加)
```
メモリ形式: [0x04]
```

### HALT (0xFF)

CPUを停止する
```
メモリ形式: [0xFF]
```

---

## 実際のプログラム例
「5 + 7を計算して出力するプログラム」
```css
[LDA_IMM][5]
[LDB_IMM][7]
[ADD]
[PRINTA]
[HALT]
```
バイト列 (16進):
```
01 05  02 07  03  04  FF
```