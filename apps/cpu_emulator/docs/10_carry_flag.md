# Carry Flag と ADC

## Carry Flag (Cフラグ)

8bit の加算結果が 255 を超えたとき, あふれた桁を記録するフラグ
```

  1111 1111 (0xFF = 255)
+ 0000 0001 (0x01 =   1)
------------------------
1 0000 0000 (0x100 = 256)
↑
この桁があふれた部分 = Carry
```

8bit レジスタには収まらないため,
- A = 0x00 (下位8bit)
- C = 1 (あふれた1bit)
として扱う

---

## このプロジェクトでの実装

### ADD (0x03)
```
A = (A + B) & 0xFF
C = (A + B) > 0xFF ? 1 : 0
Z = (A == 0) ? 1 : 0
```

### ADC (0x08)

Add with Carry: キャリーを含めた加算
```
A = (A + B + C) & 0xFF
C = (A + B + C) > 0xFF ? 1 : 0
Z = (A == 0) ? 1 : 0

メモリ形式: [0x08]
```

---

## 実行例 (16bit加算)

```
0x01FF + 0x0001 を計算する

  上位バイト  下位バイト
     0x01       0xFF    (= 0x01FF)
+    0x00       0x01    (= 0x0001)
----------------------------------
     0x02       0x00    (= 0x0200)
```

手順:
1. 下位バイト同士を ADD → 結果 + キャリー を記録
2. 上位バイト同士を ADC → キャリー(繰り上がり)も含めて加算

### 下位バイトの加算
```asm
LDA_IMM 0xFF    ; A = 0xFF (下位)
LDB_IMM 0x01    ; B = 0x01 (下位)
ADD             ; A = 0x00, C = 1 (キャリー発生)
```

### 上位バイトの加算
```asm
LDA_IMM 0x01    ; A = 0x01 (上位)
LDB_IMM 0x00    ; B = 0x00 (上位)
ADC             ; A = 0x01 + 0x00 + C(1) = 0x02
```

### 結果
```
下位: 0x00
上位: 0x02
→ 16bit値: 0x0200 = 512