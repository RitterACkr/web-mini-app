# CPU Emulator

ブラウザ上で動作する最小CPUエミュレータです.実際にアセンブリを書いて実行し,レジスタ・メモリの状態をリアルタイムで観察できます.

---

## 概要

CPUの基本構造を理解するための作りました. HTML / CSS / JavaScript で構成されたシンプルなアプリです.独自の命令セットを持った仮想CPUをJSで実装し,主に以下のデバッグ機能を備えています
- アセンブラによるプログラム実行
- ステップ実行による1つずつの実行
- ステップバックによる巻き戻し
- ブレークポイントによる自動停止

---

## 機能一覧

| **機能** | **内容** |
|----|----|
| アセンブリ実行 | テキストエリアにアセンブリを入力して実行 |
| ステップ実行 | 1命令ずつ実行して状態変化をわかりやすく |
| ステップバック | 最大100ステップ分の履歴から1手前の状態に戻る |
| 連続実行 / 停止 | 実行速度をスライダーで調整しながら自動的に実行 |
| ブレークポイント | 指定PCアドレスで実行を自動停止 |
| ウォッチポイント | 指定メモリアドレスへの書き込み時に自動停止 |
| レジスタ表示 | A / B / PC / Z / C / SP 内の値をリアルタイム表示 |
| メモリ表示 | 256バイト全メモリの内容をリアルタイムで表示 |
| メモリエディタ | メモリセルをクリックして直接値を編集 |
| ディスアセンブラ | ROMの命令列を逆にアセンブルして表示 |
| トレースログ | 各命令実行前後のレジスタ変化を詳細に記録 |
| 出力ログ | PRINTA命令による出力結果を表示 |
| サンプルプログラム | countdown / fibonacci / 8bit加算 / 16bit加算 |
| 命令リファレンス | 独自命令のため, Helpパネルによる全命令のフォーマット・動作・例を提示 |

---

## ファイル構成

```
index.html  # UI構成
style.css   # スタイル
main.js     # CPU実装・アセンブラ・ディスアセンブラ・UI制御
docs/       # 設計ドキュメント・備忘録
```

---

## 使い方

1. ブラウザで `index.html` を開く
2. テキストエリアにアセンブリを入力 / サンプルから選択
3. **Assemble** (または `Ctrl+S`) でアセンブル
4. **Step** で1命令ずつ確認, **Run** で連続実行

### デバッグ機能

- **ブレークポイント (BP)** : PC アドレスを入力して Enter → 該当アドレスで自動停止
- **ウォッチポイント (WP)** : メモリアドレスを入力して Enter → 書き込み時に自動停止
- **ステップバック** : `← Step Back` ボタンで1手前の状態に戻る
- **メモリ直接編集** : メモリ表示のセルをクリックして値を変更

---

## アセンブリの書き方

- 1行で1命令
- `;` 以降はコメント
- ラベルは `label名:` 形式
- 数値は10進数または16進数 (`0x..`)
- 定数定義は `.equ` 疑似命令を使用

```
; 5 + 7 を計算して出力する
LDA_IMM 5
LDB_IMM 7
ADD
PRINTA
HALT
```

```
; カウントダウン (5 → 0)
COUNTER .equ 0x80

LDA_IMM 5
STA_MEM COUNTER
loop:
    LDA_MEM COUNTER
    PRINTA
    CMP_A_IMM 0
    JZ end
    SUB_A_IMM 1
    STA_MEM COUNTER
    JNZ loop
end:
    HALT
```

---

## CPUアーキテクチャ

### レジスタ

| レジスタ | 説明 |
|----|----|
| A | 主演算用レジスタ |
| B | 補助演算用レジスタ |
| PC | Program Counter. 次に実行する命令のアドレス |
| Z | Zero Flag. 演算結果Aが0なら1 (True) |
| C | Carry Flag. 8bit加算のあふれを記録 |
| SP | Stack Pointer. スタックの先頭アドレス (初期値: 0xFF, 低アドレス方向に伸びる) |

### メモリ構造

メモリサイズは 256 バイト (0x00 ~ 0xFF)

- 低アドレス : プログラム領域 (命令列)
- それ以外 : データ領域 (RAM的に使用)
- 最上位アドレス : スタック領域 (0xFFから低アドレス方向へ伸びる)

### 命令セット

| 命令 | opcode | 説明 |
|----|----|----|
| LDA_IMM | 0x01 | A = 即値 |
| LDB_IMM | 0x02 | B = 即値 |
| ADD | 0x03 | A = A + B (Cフラグ更新) |
| PRINTA | 0x04 | Aの値を出力 |
| DEC_A | 0x05 | A = A - 1 |
| CMP_A_IMM | 0x06 | A と即値を比較 (Zフラグを更新, Aは変化なし) |
| SUB_A_IMM | 0x07 | A = A - 即値 |
| ADC | 0x08 | A = A + B + C (キャリーを含む加算) |
| JMP | 0x10 | 無条件ジャンプ |
| JZ | 0x11 | Z == 1 のときジャンプ |
| JNZ | 0x12 | Z == 0 のときジャンプ |
| LDA_MEM | 0x20 | A = mem[addr] |
| STA_MEM | 0x21 | mem[addr] = A |
| PUSH_A | 0x30 | A をスタックに積む |
| POP_A | 0x31 | スタックから A に取り出す |
| PUSH_B | 0x32 | B をスタックに積む |
| POP_B | 0x33 | スタックから B に取り出す |
| CALL | 0x34 | 戻り先をスタックに保存してジャンプ |
| RET | 0x35 | スタックから戻り先を取り出してジャンプ |
| HALT | 0xFF | CPUを停止 |

### 実行サイクル

```
Fetch → PCのアドレスから命令を読む / PCのインクリメント
Decode → opcodeを判別する
Execute → 命令を実行する
```

HALTが来るまで繰り返す

---

## 今後の展望

- [ ] 命令セットの拡張

---

## v1.0.0

初回リリース. 最小命令セットによるCPUエミュレータ・アセンブラの実装